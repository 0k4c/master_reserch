# ==============================================================================
# Win Ratio と Net Benefit の理論的基盤と実装
# 区間打ち切りデータに対する一般化ペアワイズ比較手法
# ==============================================================================

# -----------------------------------------------------------------------------
# 1. Win Ratio (WR) の数学的定式化
# -----------------------------------------------------------------------------

#' Win Ratio の定義
#' 
#' Win Ratio = N_win / N_loss
#' ここで：
#' - N_win: 処置群が対照群に「勝った」ペアの総数
#' - N_loss: 処置群が対照群に「負けた」ペアの総数
#' 
#' 複合エンドポイントの場合、優先順位に従って比較：
#' 1. 死亡までの時間
#' 2. 非致死的イベントまでの時間
#' などを順次比較し、最初に差が出た時点で勝敗を決定

calculate_win_ratio <- function(treatment_data, control_data, 
                                priority_outcomes = c("death", "hospitalization"),
                                horizon = NULL) {
  
  n_treat <- nrow(treatment_data)
  n_control <- nrow(control_data)
  
  # 全てのペアワイズ比較を実施
  n_pairs <- n_treat * n_control
  wins <- 0
  losses <- 0
  ties <- 0
  
  for (i in 1:n_treat) {
    for (j in 1:n_control) {
      # 各優先順位のアウトカムで比較
      for (outcome in priority_outcomes) {
        
        # 区間打ち切りデータの場合の比較ロジック
        comparison <- compare_interval_censored_pair(
          treatment_data[i, ], 
          control_data[j, ], 
          outcome,
          horizon
        )
        
        if (comparison == "win") {
          wins <- wins + 1
          break
        } else if (comparison == "loss") {
          losses <- losses + 1
          break
        }
        # tieの場合は次の優先順位へ
      }
      
      # 全ての比較でtieの場合
      if (comparison == "tie") {
        ties <- ties + 1
      }
    }
  }
  
  # Win Ratio と信頼区間の計算
  win_ratio <- wins / losses
  
  # 漸近分散の計算（U統計量理論に基づく）
  p_win <- wins / n_pairs
  p_loss <- losses / n_pairs
  
  # Finkelstein-Schoenfeld法による標準誤差
  var_log_wr <- calculate_variance_win_ratio(treatment_data, control_data, 
                                             wins, losses, ties, n_pairs)
  se_log_wr <- sqrt(var_log_wr)
  
  # 95%信頼区間（対数スケール）
  ci_lower <- exp(log(win_ratio) - 1.96 * se_log_wr)
  ci_upper <- exp(log(win_ratio) + 1.96 * se_log_wr)
  
  # 検定統計量
  z_stat <- (p_win - 0.5) / sqrt(p_win * (1 - p_win) / n_pairs)
  p_value <- 2 * (1 - pnorm(abs(z_stat)))
  
  return(list(
    win_ratio = win_ratio,
    wins = wins,
    losses = losses,
    ties = ties,
    ci_lower = ci_lower,
    ci_upper = ci_upper,
    p_value = p_value,
    z_statistic = z_stat
  ))
}

# -----------------------------------------------------------------------------
# 2. Net Benefit (NB) の数学的定式化
# -----------------------------------------------------------------------------

#' Net Benefit の定義
#' 
#' Net Benefit = (N_win - N_loss) / N_total
#' = P(win) - P(loss)
#' 
#' これは Win Ratio の線形変換：
#' NB = (WR - 1) / (WR + 1)

calculate_net_benefit <- function(treatment_data, control_data,
                                  priority_outcomes = c("death", "hospitalization"),
                                  horizon = NULL) {
  
  n_treat <- nrow(treatment_data)
  n_control <- nrow(control_data)
  n_pairs <- n_treat * n_control
  
  # Win Ratio計算と同じロジック
  wins <- 0
  losses <- 0
  ties <- 0
  
  # ペアワイズ比較の詳細を保存（分散計算用）
  pair_results <- matrix(0, n_treat, n_control)
  
  for (i in 1:n_treat) {
    for (j in 1:n_control) {
      result <- compare_pair_hierarchical(
        treatment_data[i, ], 
        control_data[j, ],
        priority_outcomes,
        horizon
      )
      
      if (result == 1) {  # win
        wins <- wins + 1
        pair_results[i, j] <- 1
      } else if (result == -1) {  # loss
        losses <- losses + 1
        pair_results[i, j] <- -1
      } else {  # tie
        ties <- ties + 1
        pair_results[i, j] <- 0
      }
    }
  }
  
  # Net Benefit の計算
  net_benefit <- (wins - losses) / n_pairs
  
  # U統計量理論による漸近分散
  var_nb <- calculate_variance_net_benefit(pair_results, n_treat, n_control)
  se_nb <- sqrt(var_nb)
  
  # 95%信頼区間
  ci_lower <- net_benefit - 1.96 * se_nb
  ci_upper <- net_benefit + 1.96 * se_nb
  
  # 検定統計量
  z_stat <- net_benefit / se_nb
  p_value <- 2 * (1 - pnorm(abs(z_stat)))
  
  return(list(
    net_benefit = net_benefit,
    wins = wins,
    losses = losses,
    ties = ties,
    ci_lower = ci_lower,
    ci_upper = ci_upper,
    se = se_nb,
    z_statistic = z_stat,
    p_value = p_value
  ))
}

# -----------------------------------------------------------------------------
# 3. 区間打ち切りデータでのペア比較
# -----------------------------------------------------------------------------

compare_interval_censored_pair <- function(treat_obs, control_obs, 
                                           outcome, horizon) {
  
  # 区間打ち切りデータの構造: [L, R]
  # L: 左端点（イベントがこの時点以降に発生）
  # R: 右端点（イベントがこの時点以前に発生）
  
  treat_L <- treat_obs[paste0(outcome, "_L")]
  treat_R <- treat_obs[paste0(outcome, "_R")]
  control_L <- control_obs[paste0(outcome, "_L")]
  control_R <- control_obs[paste0(outcome, "_R")]
  
  # horizonで打ち切り
  if (!is.null(horizon)) {
    treat_R <- min(treat_R, horizon)
    control_R <- min(control_R, horizon)
  }
  
  # 比較ルール（Fay and Shih, 1998）
  if (treat_R < control_L) {
    # 処置群が明らかに早い → loss
    return("loss")
  } else if (control_R < treat_L) {
    # 対照群が明らかに早い → win
    return("win")
  } else {
    # 区間が重複 → tie
    return("tie")
  }
}

# -----------------------------------------------------------------------------
# 4. 階層的複合エンドポイントの比較
# -----------------------------------------------------------------------------

compare_pair_hierarchical <- function(treat_obs, control_obs, 
                                      priority_outcomes, horizon) {
  
  for (outcome in priority_outcomes) {
    # 各アウトカムで比較
    if (outcome == "death") {
      # 死亡の比較（最優先）
      result <- compare_interval_censored_pair(
        treat_obs, control_obs, "death", horizon
      )
    } else {
      # 死亡していない場合のみ、次のアウトカムを比較
      if (!is_dead_before_horizon(treat_obs, horizon) && 
          !is_dead_before_horizon(control_obs, horizon)) {
        result <- compare_interval_censored_pair(
          treat_obs, control_obs, outcome, horizon
        )
      } else {
        # どちらかが死亡している場合は前の比較結果を使用
        next
      }
    }
    
    if (result != "tie") {
      return(ifelse(result == "win", 1, -1))
    }
  }
  
  return(0)  # 全てtie
}

# -----------------------------------------------------------------------------
# 5. 分散推定（U統計量理論）
# -----------------------------------------------------------------------------

calculate_variance_win_ratio <- function(treatment_data, control_data,
                                         wins, losses, ties, n_pairs) {
  
  n_treat <- nrow(treatment_data)
  n_control <- nrow(control_data)
  
  # Luo et al. (2015) の方法による分散推定
  # U統計量の漸近分散を計算
  
  # 各患者のスコアを計算
  treat_scores <- numeric(n_treat)
  control_scores <- numeric(n_control)
  
  # 省略: 詳細な実装は論文参照
  # ここでは簡易版
  p_win <- wins / n_pairs
  p_loss <- losses / n_pairs
  
  # デルタ法による対数Win Ratioの分散
  var_log_wr <- (1/wins + 1/losses) / n_pairs
  
  return(var_log_wr)
}

calculate_variance_net_benefit <- function(pair_results, n_treat, n_control) {
  
  # U統計量の分散計算
  # Hoeffding分解を使用
  
  n_pairs <- n_treat * n_control
  
  # 各処置群患者のスコア
  treat_scores <- rowMeans(pair_results)
  
  # 各対照群患者のスコア  
  control_scores <- colMeans(pair_results)
  
  # 分散成分
  var_1 <- var(treat_scores) / n_treat
  var_2 <- var(control_scores) / n_control
  
  # 全体の分散
  var_nb <- var_1 + var_2
  
  return(var_nb)
}

# -----------------------------------------------------------------------------
# 6. 検出力計算関数
# -----------------------------------------------------------------------------

calculate_power_win_ratio <- function(n_treat, n_control, true_wr, 
                                      alpha = 0.05, n_sim = 1000) {
  
  # 真のWin Ratioに基づく検出力をシミュレーション
  significant_count <- 0
  
  for (i in 1:n_sim) {
    # データ生成
    data <- generate_data_with_true_wr(n_treat, n_control, true_wr)
    
    # Win Ratio計算
    result <- calculate_win_ratio(
      data$treatment, 
      data$control
    )
    
    # 有意性判定
    if (result$p_value < alpha) {
      significant_count <- significant_count + 1
    }
  }
  
  power <- significant_count / n_sim
  return(power)
}

# -----------------------------------------------------------------------------
# 7. RMST（Restricted Mean Survival Time）との比較
# -----------------------------------------------------------------------------

calculate_rmst_interval_censored <- function(interval_data, tau, 
                                             imputation = "midpoint") {
  
  # 区間打ち切りデータの補完
  if (imputation == "midpoint") {
    imputed_data <- midpoint_assignment(interval_data)
  } else if (imputation == "rightpoint") {
    imputed_data <- rightpoint_assignment(interval_data)
  }
  
  # Kaplan-Meier推定
  library(survival)
  km_fit <- survfit(Surv(time, cens) ~ 1, data = imputed_data)
  
  # RMST計算
  # τまでの生存曲線下面積
  times <- c(0, km_fit$time[km_fit$time <= tau], tau)
  survs <- c(1, km_fit$surv[km_fit$time <= tau])
  
  if (length(survs) < length(times)) {
    survs <- c(survs, tail(survs, 1))
  }
  
  # 台形則で積分
  rmst <- 0
  for (i in 1:(length(times)-1)) {
    rmst <- rmst + (times[i+1] - times[i]) * (survs[i] + survs[i+1]) / 2
  }
  
  # Greenwood公式による分散
  var_rmst <- calculate_rmst_variance(km_fit, tau)
  
  return(list(
    rmst = rmst,
    se = sqrt(var_rmst)
  ))
}

# -----------------------------------------------------------------------------
# 使用例
# -----------------------------------------------------------------------------

# # データ生成
 set.seed(123)
 n <- 200
 
 # 区間打ち切りデータの生成
 treatment_data <- generate_interval_censored_data_2arm(
   n = n/2, K = 5, p_dropout = "Medium", p_exact = 0.2, d = 1
 )
 
 control_data <- generate_interval_censored_data_2arm(
   n = n/2, K = 5, p_dropout = "Medium", p_exact = 0.2, d = 6
 )
 
 # Win Ratio の計算
 wr_result <- calculate_win_ratio(treatment_data, control_data)
 print(wr_result)
 
 # Net Benefit の計算
 nb_result <- calculate_net_benefit(treatment_data, control_data)
 print(nb_result)