} else {
ties <- ties + 1
}
} else if (event_treat == 0 && event_control == 1) {
# 対照群のみイベント発生
if (t_treat > t_control) {
losses <- losses + 1
} else {
ties <- ties + 1
}
} else {
# 両方打ち切り
ties <- ties + 1
}
}
}
total_pairs <- n_treatment * n_control
if (method == "net_benefit") {
net_benefit <- (wins - losses) / total_pairs
variance <- (wins + losses + ties/4) / (total_pairs^2)
if (variance <= 0) variance <- 1 / (4 * total_pairs)
z_stat <- net_benefit / sqrt(variance)
p_value <- 2 * (1 - pnorm(abs(z_stat)))
return(list(
method = "Imputation_NetBenefit",
estimate = net_benefit,
p_value = p_value
))
} else if (method == "win_ratio") {
if (losses == 0) {
win_ratio <- ifelse(wins > 0, Inf, 1)
p_value <- ifelse(wins > 0, 0, 1)
} else if (wins == 0) {
win_ratio <- 0
p_value <- 0
} else {
win_ratio <- wins / losses
log_var <- 1/wins + 1/losses
z_stat <- log(win_ratio) / sqrt(log_var)
p_value <- 2 * (1 - pnorm(abs(z_stat)))
}
return(list(
method = "Imputation_WinRatio",
estimate = win_ratio,
p_value = p_value
))
}
}
# ===============================================================================
# 3. 従来手法（RMST・ログランク検定）
# ===============================================================================
# RMST（改良版）
rmst_improved <- function(data_control, data_treatment, tau = 1, imputation_method = "midpoint") {
tryCatch({
if (imputation_method == "midpoint") {
surv_control <- midpoint_assignment(data_control)
surv_treatment <- midpoint_assignment(data_treatment)
} else if (imputation_method == "rightpoint") {
surv_control <- rightpoint_assignment(data_control)
surv_treatment <- rightpoint_assignment(data_treatment)
}
# Mann-Whitney U検定で近似
wilcox_result <- wilcox.test(surv_treatment$time, surv_control$time,
alternative = "two.sided")
return(list(
method = paste0("RMST_", imputation_method),
estimate = median(surv_treatment$time) - median(surv_control$time),
p_value = wilcox_result$p.value
))
}, error = function(e) {
return(list(method = paste0("RMST_", imputation_method), estimate = 0, p_value = 1))
})
}
# ログランク検定（改良版）
logrank_improved <- function(data_control, data_treatment, imputation_method = "midpoint") {
tryCatch({
if (imputation_method == "midpoint") {
surv_control <- midpoint_assignment(data_control)
surv_treatment <- midpoint_assignment(data_treatment)
} else if (imputation_method == "rightpoint") {
surv_control <- rightpoint_assignment(data_control)
surv_treatment <- rightpoint_assignment(data_treatment)
}
combined_data <- rbind(
cbind(surv_control, group = 0),
cbind(surv_treatment, group = 1)
)
survdiff_result <- survdiff(Surv(time, cens) ~ group, data = combined_data)
p_value <- 1 - pchisq(survdiff_result$chisq, df = 1)
return(list(
method = paste0("LogRank_", imputation_method),
estimate = sqrt(survdiff_result$chisq),
p_value = p_value
))
}, error = function(e) {
return(list(method = paste0("LogRank_", imputation_method), estimate = 0, p_value = 1))
})
}
# ===============================================================================
# 4. 最終版シミュレーション関数
# ===============================================================================
run_final_simulation <- function(
n_sim = 1000,
sample_sizes = c(100, 200),
K_values = c(3, 5),
dropout_levels = c("None", "Medium"),
effect_sizes = c(1, 6, 12),
alpha = 0.05,
n_cores = NULL,  # NULLの場合は自動検出
use_parallel = TRUE,
show_progress = TRUE
) {
research_design()  # 研究デザインの表示
# コア数の設定
if (is.null(n_cores)) {
n_cores <- max(1, parallel::detectCores() - 1)
}
cat("使用コア数:", n_cores, "/ 利用可能コア数:", parallel::detectCores(), "\n")
cat("並列処理:", ifelse(use_parallel && n_cores > 1, "有効", "無効"), "\n")
conditions <- expand.grid(
n = sample_sizes,
K = K_values,
dropout = dropout_levels,
effect = effect_sizes,
stringsAsFactors = FALSE
)
cat("シミュレーション条件数:", nrow(conditions), "\n")
cat("総シミュレーション数:", nrow(conditions) * n_sim, "\n\n")
# プログレスバーの初期化
total_sims <- nrow(conditions) * n_sim
if (show_progress) {
pb <- progress_bar$new(
format = "  シミュレーション実行中 [:bar] :percent :current/:total ETA: :eta",
total = total_sims,
clear = FALSE,
width = 80
)
}
results <- data.frame()
# 並列処理の設定
if (use_parallel && n_cores > 1) {
cl <- makeCluster(n_cores)
registerDoParallel(cl)
cat("並列処理クラスターを", n_cores, "コアで開始しました\n\n")
# 必要なパッケージとソースをワーカーに送信
clusterEvalQ(cl, {
library(survival)
library(tidyverse)
})
# 関数をワーカーに送信
clusterExport(cl, c("generate_interval_censored_data_2arm",
"gpc_direct_improved", "gpc_with_imputation_improved",
"rmst_improved", "logrank_improved"))
}
for (i in 1:nrow(conditions)) {
n <- conditions$n[i]
K <- conditions$K[i]
dropout <- conditions$dropout[i]
effect <- conditions$effect[i]
cat(sprintf("条件 %d/%d: n=%d, K=%d, dropout=%s, effect=%d\n",
i, nrow(conditions), n, K, dropout, effect))
if (use_parallel && n_cores > 1) {
# 並列処理版
sim_results <- foreach(sim = 1:n_sim, .combine = rbind, .packages = c("survival", "tidyverse")) %dopar% {
tryCatch({
# データ生成
data_control <- generate_interval_censored_data_2arm(n = n/2, K = K,
p_dropout = dropout, d = 1)
data_treatment <- generate_interval_censored_data_2arm(n = n/2, K = K,
p_dropout = dropout, d = effect)
# 1. GPC Direct（代入なし）
gpc_direct_nb <- gpc_direct_improved(data_control, data_treatment, "net_benefit")
gpc_direct_wr <- gpc_direct_improved(data_control, data_treatment, "win_ratio")
# 2. GPC + Midpoint
gpc_mid_nb <- gpc_with_imputation_improved(data_control, data_treatment,
"midpoint", "net_benefit")
gpc_mid_wr <- gpc_with_imputation_improved(data_control, data_treatment,
"midpoint", "win_ratio")
# 3. GPC + Rightpoint
gpc_right_nb <- gpc_with_imputation_improved(data_control, data_treatment,
"rightpoint", "net_benefit")
gpc_right_wr <- gpc_with_imputation_improved(data_control, data_treatment,
"rightpoint", "win_ratio")
# 4. GPC + Enhanced EMI
gpc_emi_nb <- gpc_with_imputation_improved(data_control, data_treatment,
"enhanced_emi", "net_benefit")
gpc_emi_wr <- gpc_with_imputation_improved(data_control, data_treatment,
"enhanced_emi", "win_ratio")
# 5. 従来手法
rmst_mid <- rmst_improved(data_control, data_treatment, imputation_method = "midpoint")
lr_mid <- logrank_improved(data_control, data_treatment, imputation_method = "midpoint")
# 結果をまとめる
data.frame(
sim_id = sim,
n = n, K = K, dropout = dropout, effect = effect,
# 棄却判定
gpc_direct_nb_reject = gpc_direct_nb$p_value < alpha,
gpc_direct_wr_reject = gpc_direct_wr$p_value < alpha,
gpc_mid_nb_reject = gpc_mid_nb$p_value < alpha,
gpc_mid_wr_reject = gpc_mid_wr$p_value < alpha,
gpc_right_nb_reject = gpc_right_nb$p_value < alpha,
gpc_right_wr_reject = gpc_right_wr$p_value < alpha,
gpc_emi_nb_reject = gpc_emi_nb$p_value < alpha,
gpc_emi_wr_reject = gpc_emi_wr$p_value < alpha,
rmst_mid_reject = rmst_mid$p_value < alpha,
lr_mid_reject = lr_mid$p_value < alpha,
# p値
gpc_direct_nb_pvalue = gpc_direct_nb$p_value,
gpc_direct_wr_pvalue = gpc_direct_wr$p_value,
gpc_mid_nb_pvalue = gpc_mid_nb$p_value,
gpc_mid_wr_pvalue = gpc_mid_wr$p_value,
gpc_right_nb_pvalue = gpc_right_nb$p_value,
gpc_right_wr_pvalue = gpc_right_wr$p_value,
gpc_emi_nb_pvalue = gpc_emi_nb$p_value,
gpc_emi_wr_pvalue = gpc_emi_wr$p_value,
rmst_mid_pvalue = rmst_mid$p_value,
lr_mid_pvalue = lr_mid$p_value
)
}, error = function(e) {
# エラー時はNULLを返す
NULL
})
}
# プログレスバー更新
if (show_progress) {
pb$tick(n_sim)
}
} else {
# 逐次処理版
sim_results <- data.frame()
for (sim in 1:n_sim) {
tryCatch({
# データ生成
data_control <- generate_interval_censored_data_2arm(n = n/2, K = K,
p_dropout = dropout, d = 1)
data_treatment <- generate_interval_censored_data_2arm(n = n/2, K = K,
p_dropout = dropout, d = effect)
# 1. GPC Direct（代入なし）
gpc_direct_nb <- gpc_direct_improved(data_control, data_treatment, "net_benefit")
gpc_direct_wr <- gpc_direct_improved(data_control, data_treatment, "win_ratio")
# 2. GPC + Midpoint
gpc_mid_nb <- gpc_with_imputation_improved(data_control, data_treatment,
"midpoint", "net_benefit")
gpc_mid_wr <- gpc_with_imputation_improved(data_control, data_treatment,
"midpoint", "win_ratio")
# 3. GPC + Rightpoint
gpc_right_nb <- gpc_with_imputation_improved(data_control, data_treatment,
"rightpoint", "net_benefit")
gpc_right_wr <- gpc_with_imputation_improved(data_control, data_treatment,
"rightpoint", "win_ratio")
# 4. GPC + Enhanced EMI
gpc_emi_nb <- gpc_with_imputation_improved(data_control, data_treatment,
"enhanced_emi", "net_benefit")
gpc_emi_wr <- gpc_with_imputation_improved(data_control, data_treatment,
"enhanced_emi", "win_ratio")
# 5. 従来手法
rmst_mid <- rmst_improved(data_control, data_treatment, imputation_method = "midpoint")
lr_mid <- logrank_improved(data_control, data_treatment, imputation_method = "midpoint")
# 結果をまとめる
sim_result <- data.frame(
sim_id = sim,
n = n, K = K, dropout = dropout, effect = effect,
# 棄却判定
gpc_direct_nb_reject = gpc_direct_nb$p_value < alpha,
gpc_direct_wr_reject = gpc_direct_wr$p_value < alpha,
gpc_mid_nb_reject = gpc_mid_nb$p_value < alpha,
gpc_mid_wr_reject = gpc_mid_wr$p_value < alpha,
gpc_right_nb_reject = gpc_right_nb$p_value < alpha,
gpc_right_wr_reject = gpc_right_wr$p_value < alpha,
gpc_emi_nb_reject = gpc_emi_nb$p_value < alpha,
gpc_emi_wr_reject = gpc_emi_wr$p_value < alpha,
rmst_mid_reject = rmst_mid$p_value < alpha,
lr_mid_reject = lr_mid$p_value < alpha,
# p値
gpc_direct_nb_pvalue = gpc_direct_nb$p_value,
gpc_direct_wr_pvalue = gpc_direct_wr$p_value,
gpc_mid_nb_pvalue = gpc_mid_nb$p_value,
gpc_mid_wr_pvalue = gpc_mid_wr$p_value,
gpc_right_nb_pvalue = gpc_right_nb$p_value,
gpc_right_wr_pvalue = gpc_right_wr$p_value,
gpc_emi_nb_pvalue = gpc_emi_nb$p_value,
gpc_emi_wr_pvalue = gpc_emi_wr$p_value,
rmst_mid_pvalue = rmst_mid$p_value,
lr_mid_pvalue = lr_mid$p_value
)
sim_results <- rbind(sim_results, sim_result)
# プログレスバー更新
if (show_progress) {
pb$tick()
}
}, error = function(e) {
cat("エラー (sim", sim, "):", e$message, "\n")
# プログレスバー更新
if (show_progress) {
pb$tick()
}
})
}
}
results <- rbind(results, sim_results)
# 進捗表示
if (nrow(sim_results) > 0) {
avg_power <- mean(sim_results$gpc_direct_nb_reject, na.rm = TRUE)
cat(sprintf("  -> 完了 (%d シミュレーション): 平均検出力 = %.3f\n",
nrow(sim_results), avg_power))
}
}
# 並列処理クラスターのクリーンアップ
if (use_parallel && n_cores > 1) {
stopCluster(cl)
cat("\n並列処理クラスターを終了しました\n")
}
return(results)
}
# ===============================================================================
# 5. 結果分析関数
# ===============================================================================
analyze_final_results <- function(results) {
# 検出力の計算
power_summary <- results %>%
group_by(n, K, dropout, effect) %>%
summarise(
# GPC各手法の検出力
GPC_Direct_NB = mean(gpc_direct_nb_reject, na.rm = TRUE),
GPC_Direct_WR = mean(gpc_direct_wr_reject, na.rm = TRUE),
GPC_Midpoint_NB = mean(gpc_mid_nb_reject, na.rm = TRUE),
GPC_Midpoint_WR = mean(gpc_mid_wr_reject, na.rm = TRUE),
GPC_Rightpoint_NB = mean(gpc_right_nb_reject, na.rm = TRUE),
GPC_Rightpoint_WR = mean(gpc_right_wr_reject, na.rm = TRUE),
GPC_EnhancedEMI_NB = mean(gpc_emi_nb_reject, na.rm = TRUE),
GPC_EnhancedEMI_WR = mean(gpc_emi_wr_reject, na.rm = TRUE),
# 従来手法の検出力
RMST_Midpoint = mean(rmst_mid_reject, na.rm = TRUE),
LogRank_Midpoint = mean(lr_mid_reject, na.rm = TRUE),
.groups = "drop"
)
# 第1種の誤りの計算
type1_summary <- results %>%
filter(effect == 1) %>%
group_by(n, K, dropout) %>%
summarise(
GPC_Direct_NB = mean(gpc_direct_nb_reject, na.rm = TRUE),
GPC_Direct_WR = mean(gpc_direct_wr_reject, na.rm = TRUE),
GPC_Midpoint_NB = mean(gpc_mid_nb_reject, na.rm = TRUE),
GPC_Midpoint_WR = mean(gpc_mid_wr_reject, na.rm = TRUE),
GPC_Rightpoint_NB = mean(gpc_right_nb_reject, na.rm = TRUE),
GPC_Rightpoint_WR = mean(gpc_right_wr_reject, na.rm = TRUE),
GPC_EnhancedEMI_NB = mean(gpc_emi_nb_reject, na.rm = TRUE),
GPC_EnhancedEMI_WR = mean(gpc_emi_wr_reject, na.rm = TRUE),
RMST_Midpoint = mean(rmst_mid_reject, na.rm = TRUE),
LogRank_Midpoint = mean(lr_mid_reject, na.rm = TRUE),
.groups = "drop"
)
# 主要結果の表示
cat("===============================================================================\n")
cat("                             研究結果サマリー\n")
cat("===============================================================================\n")
# Q1: GPCにおける最良の代入法
gpc_power_avg <- power_summary %>%
filter(effect != 1) %>%
summarise(
Direct_NB = mean(GPC_Direct_NB),
Direct_WR = mean(GPC_Direct_WR),
Midpoint_NB = mean(GPC_Midpoint_NB),
Midpoint_WR = mean(GPC_Midpoint_WR),
Rightpoint_NB = mean(GPC_Rightpoint_NB),
Rightpoint_WR = mean(GPC_Rightpoint_WR),
EnhancedEMI_NB = mean(GPC_EnhancedEMI_NB),
EnhancedEMI_WR = mean(GPC_EnhancedEMI_WR)
)
cat("Q1: GPCにおける代入法の検出力比較 (平均):\n")
print(round(gpc_power_avg, 3))
# Q2: GPC vs 従来手法
method_comparison <- power_summary %>%
filter(effect != 1) %>%
summarise(
Best_GPC = max(c(mean(GPC_Direct_NB), mean(GPC_Midpoint_NB),
mean(GPC_Rightpoint_NB), mean(GPC_EnhancedEMI_NB))),
RMST = mean(RMST_Midpoint),
LogRank = mean(LogRank_Midpoint)
)
cat("\nQ2: GPC vs 従来手法の検出力比較:\n")
print(round(method_comparison, 3))
# 第1種の誤りチェック
cat("\n第1種の誤り率 (目標: 0.05前後):\n")
type1_avg <- type1_summary %>%
summarise_if(is.numeric, mean)
print(round(type1_avg, 3))
return(list(
power_summary = power_summary,
type1_summary = type1_summary,
gpc_comparison = gpc_power_avg,
method_comparison = method_comparison
))
}
# ===============================================================================
# 6. 実行関数
# ===============================================================================
run_final_study <- function() {
cat("=== 最終版：代入法比較研究の実行 ===\n")
# 小規模テスト
test_results <- run_final_simulation(
n_sim = 100,
sample_sizes = 100,
K_values = 3,
dropout_levels = "None",
effect_sizes = c(1, 6),
n_cores = 1
)
# 結果分析
analysis <- analyze_final_results(test_results)
return(list(
simulation_results = test_results,
analysis = analysis
))
}
cat("===============================================================================\n")
cat("         最終版：一般化ペアワイズ比較における代入法比較研究\n")
cat("===============================================================================\n")
cat("実行方法:\n")
cat("1. final_results <- run_final_study()  # テスト実行\n")
cat("2. 結果の確認とp値の妥当性をチェック\n")
cat("3. 必要に応じてパラメータ調整\n")
cat("===============================================================================\n")
final_results <- run_final_study()
full_results <- run_final_simulation(
n_sim = 1000,
sample_sizes = c(100, 200, 400),
K_values = c(3, 5, 10),
dropout_levels = c("None", "Low", "Medium", "High"),
effect_sizes = 1:24,
n_cores = 8,          # コア数指定（NULLで自動検出）
use_parallel = TRUE,  # 並列処理有効
show_progress = FALSE  # プログレスバー表示
)
full_results <- run_final_simulation(
n_sim = 1000,
sample_sizes = c(100, 200, 400),
K_values = c(3, 5, 10),
dropout_levels = c("None", "Low", "Medium", "High"),
effect_sizes = 1:24,
n_cores = 8,          # コア数指定（NULLで自動検出）
use_parallel = FALSE,  # 並列処理有効
show_progress = FALSE  # プログレスバー表示
)
full_results <- run_final_simulation(
n_sim = 1000,
sample_sizes = c(100, 200, 400),
K_values = c(3, 5, 10),
dropout_levels = c("None", "Low", "Medium", "High"),
effect_sizes = 1:24,
n_cores = 8,          # コア数指定（NULLで自動検出）
use_parallel = turbine,  # 並列処理有効
show_progress = FALSE  # プログレスバー表示
)
function (test, yes, no)
{
if (is.atomic(test)) {
if (typeof(test) != "logical")
storage.mode(test) <- "logical"
if (length(test) == 1 && is.null(attributes(test))) {
if (is.na(test))
return(NA)
else if (test) {
if (length(yes) == 1) {
yat <- attributes(yes)
if (is.null(yat) || (is.function(yes) && identical(names(yat),
"srcref")))
return(yes)
}
}
else if (length(no) == 1) {
nat <- attributes(no)
if (is.null(nat) || (is.function(no) && identical(names(nat),
"srcref")))
return(no)
}
}
}
else test <- if (isS4(test))
methods::as(test, "logical")
else as.logical(test)
ans <- test
len <- length(ans)
ypos <- which(test)
npos <- which(!test)
if (length(ypos) > 0L)
ans[ypos] <- rep(yes, length.out = len)[ypos]
if (length(npos) > 0L)
ans[npos] <- rep(no, length.out = len)[npos]
ans
}
full_results <- run_final_simulation(
n_sim = 1000,
sample_sizes = c(100, 200, 400),
K_values = c(3, 5, 10),
dropout_levels = c("None", "Low", "Medium", "High"),
effect_sizes = 1:24,
n_cores = 8,          # コア数指定（NULLで自動検出）
use_parallel = TRUE,  # 並列処理有効
show_progress = TRUE  # プログレスバー表示
)
full_results <- run_final_simulation(
n_sim = 1000,
sample_sizes = c(100, 200, 400),
K_values = c(3, 5, 10),
dropout_levels = c("None", "Low", "Medium", "High"),
effect_sizes = 1:24,
n_cores = 8,          # コア数指定（NULLで自動検出）
use_parallel = TRUE,  # 並列処理有効
show_progress = FALSE  # プログレスバー表示
)
